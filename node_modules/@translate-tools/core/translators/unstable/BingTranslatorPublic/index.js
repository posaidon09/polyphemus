"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BingTranslatorPublic = void 0;

var _BaseTranslator = require("../../../util/BaseTranslator");

var _Multiplexor = require("../../../lib/Multiplexor");

var _fetchResponseToJson = require("../../../lib/fetchResponseToJson");

var _getConfig = require("./getConfig");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

/**
 * This translator is very slow for translate page, but may use to translate user input
 */
var BingTranslatorPublic =
/** @class */
function (_super) {
  __extends(BingTranslatorPublic, _super);

  function BingTranslatorPublic() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.mtp = new _Multiplexor.Multiplexor({
      tokenStart: 'ðŸ˜€',
      tokenEnd: 'ðŸ˜ƒ'
    });
    return _this;
  }

  BingTranslatorPublic.isSupportedAutoFrom = function () {
    return true;
  };

  BingTranslatorPublic.getSupportedLanguages = function () {
    // eslint-disable
    // prettier-ignore
    return ['en', 'ar', 'af', 'bg', 'cy', 'hu', 'vi', 'el', 'da', 'he', 'id', 'is', 'es', 'it', 'ca', 'ko', 'ht', 'lv', 'lt', 'mg', 'ms', 'mt', 'de', 'nl', 'nb', 'fa', 'pl', 'pt', 'ro', 'ru', 'sm', 'sk', 'sl', 'sw', 'ty', 'th', 'ta', 'te', 'to', 'tr', 'uk', 'ur', 'fj', 'fi', 'fr', 'hi', 'hr', 'cs', 'sv', 'et', 'ja']; // eslint-enable
  };

  BingTranslatorPublic.prototype.getLengthLimit = function () {
    return 3000;
  };

  BingTranslatorPublic.prototype.getRequestsTimeout = function () {
    return 500;
  };

  BingTranslatorPublic.prototype.checkLimitExceeding = function (text) {
    if (Array.isArray(text)) {
      var encodedText = this.mtp.encode(text.map(function (text, id) {
        return {
          text: text,
          id: '' + id
        };
      }));
      var extra = encodedText.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      var extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  };

  BingTranslatorPublic.prototype.encodeObject = function (obj) {
    return Object.keys(obj).map(function (key) {
      return key + '=' + encodeURIComponent(obj[key]);
    }).join('&');
  }; // This fn was copy from toolKit for independentcy


  BingTranslatorPublic.prototype.findInObj = function (obj, path, notFound) {
    if (notFound === void 0) {
      notFound = undefined;
    }

    try {
      return path.reduce(function (x, y) {
        if (y in x) {
          return x[y];
        } else {
          throw Error('Not found');
        }
      }, obj);
    } catch (e) {
      return notFound;
    }
  };

  BingTranslatorPublic.prototype.translate = function (text, from, to) {
    return __awaiter(this, void 0, void 0, function () {
      var fixedFrom, _a, IIG, IID, key, token;

      var _this = this;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            fixedFrom = from === 'auto' ? 'auto-detect' : from;
            return [4
            /*yield*/
            , (0, _getConfig.getConfig)()];

          case 1:
            _a = _b.sent(), IIG = _a.IIG, IID = _a.IID, key = _a.key, token = _a.token;
            return [2
            /*return*/
            , fetch(this.wrapUrlToCorsProxy("https://www.bing.com/ttranslatev3?isVertical=1&=&IG=".concat(IIG, "&=&IID=").concat(IID)), {
              method: 'POST',
              headers: __assign({
                'Content-type': 'application/x-www-form-urlencoded'
              }, this.options.headers),
              body: '&' + this.encodeObject({
                fromLang: fixedFrom,
                to: to,
                text: text,
                token: token,
                key: key
              })
            }).then(_fetchResponseToJson.fetchResponseToJson).then(function (rsp) {
              var text = _this.findInObj(rsp, [0, 'translations', 0, 'text']);

              if (typeof text === 'string') {
                return text;
              } else {
                if ('StatusCode' in rsp) {
                  throw new Error("Unknown error. Code ".concat(rsp['StatusCode']));
                } else {
                  throw new Error("Unknown error");
                }
              }
            })];
        }
      });
    });
  };

  BingTranslatorPublic.prototype.translateBatch = function (text, langFrom, langTo) {
    var _this = this;

    var encodedText = this.mtp.encode(text.map(function (text, id) {
      return {
        text: text,
        id: '' + id
      };
    }));
    return this.translate(encodedText, langFrom, langTo).then(function (rawTranslate) {
      var result = Array(text.length);

      var decodedMap = _this.mtp.decode(rawTranslate);

      decodedMap.forEach(function (_a) {
        var id = _a.id,
            text = _a.text;
        var index = +id;
        result[index] = text;
      });
      return result;
    });
  };

  BingTranslatorPublic.translatorName = 'BingTranslator (public)';
  return BingTranslatorPublic;
}(_BaseTranslator.BaseTranslator);

exports.BingTranslatorPublic = BingTranslatorPublic;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyYW5zbGF0b3JzL3Vuc3RhYmxlL0JpbmdUcmFuc2xhdG9yUHVibGljL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFRztBQUNILElBQUEsb0JBQUE7QUFBQTtBQUFBLFVBQUEsTUFBQSxFQUFBO0FBQTBDLEVBQUEsU0FBQSxDQUFBLG9CQUFBLEVBQUEsTUFBQSxDQUFBOztBQUExQyxXQUFBLG9CQUFBLEdBQUE7QUFBQSxRQUFBLEtBQUEsR0FBQSxNQUFBLEtBQUEsSUFBQSxJQUFBLE1BQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxFQUFBLFNBQUEsQ0FBQSxJQUFBLElBQUE7O0FBMEdrQixJQUFBLEtBQUEsQ0FBQSxHQUFBLEdBQU0sSUFBSSx3QkFBSixDQUFnQjtBQUFFLE1BQUEsVUFBVSxFQUFFLElBQWQ7QUFBb0IsTUFBQSxRQUFRLEVBQUU7QUFBOUIsS0FBaEIsQ0FBTjs7QUFrQmpCOztBQXpIYyxFQUFBLG9CQUFBLENBQUEsbUJBQUEsR0FBZCxZQUFBO0FBQ0MsV0FBTyxJQUFQO0FBQ0EsR0FGYTs7QUFJQSxFQUFBLG9CQUFBLENBQUEscUJBQUEsR0FBZCxZQUFBO0FBQ0M7QUFDQTtBQUNBLFdBQU8sQ0FDTixJQURNLEVBQ0EsSUFEQSxFQUNNLElBRE4sRUFDWSxJQURaLEVBQ2tCLElBRGxCLEVBQ3dCLElBRHhCLEVBQzhCLElBRDlCLEVBQ29DLElBRHBDLEVBQzBDLElBRDFDLEVBQ2dELElBRGhELEVBRU4sSUFGTSxFQUVBLElBRkEsRUFFTSxJ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QSxFQUFBLENBQUEsRTtZQUFFLElBQUksR0FBQSxFQUFBLENBQUEsSTtBQUM3QixZQUFNLEtBQUssR0FBRyxDQUFDLEVBQWY7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFELENBQU4sR0FBZ0IsSUFBaEI7QUFDQSxPQUhEO0FBS0EsYUFBTyxNQUFQO0FBQ0EsS0FWTSxDQUFQO0FBV0EsR0FoQk07O0FBMUdnQixFQUFBLG9CQUFBLENBQUEsY0FBQSxHQUFpQix5QkFBakI7QUEySHhCLFNBQUEsb0JBQUE7QUFBQyxDQTVIRCxDQUEwQyw4QkFBMUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxhbmdDb2RlLCBsYW5nQ29kZVdpdGhBdXRvIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvVHJhbnNsYXRvcic7XG5pbXBvcnQgeyBCYXNlVHJhbnNsYXRvciB9IGZyb20gJy4uLy4uLy4uL3V0aWwvQmFzZVRyYW5zbGF0b3InO1xuaW1wb3J0IHsgTXVsdGlwbGV4b3IgfSBmcm9tICcuLi8uLi8uLi9saWIvTXVsdGlwbGV4b3InO1xuaW1wb3J0IHsgZmV0Y2hSZXNwb25zZVRvSnNvbiB9IGZyb20gJy4uLy4uLy4uL2xpYi9mZXRjaFJlc3BvbnNlVG9Kc29uJztcblxuaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnLi9nZXRDb25maWcnO1xuXG4vKipcbiAqIFRoaXMgdHJhbnNsYXRvciBpcyB2ZXJ5IHNsb3cgZm9yIHRyYW5zbGF0ZSBwYWdlLCBidXQgbWF5IHVzZSB0byB0cmFuc2xhdGUgdXNlciBpbnB1dFxuICovXG5leHBvcnQgY2xhc3MgQmluZ1RyYW5zbGF0b3JQdWJsaWMgZXh0ZW5kcyBCYXNlVHJhbnNsYXRvciB7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdHJhbnNsYXRvck5hbWUgPSAnQmluZ1RyYW5zbGF0b3IgKHB1YmxpYyknO1xuXG5cdHB1YmxpYyBzdGF0aWMgaXNTdXBwb3J0ZWRBdXRvRnJvbSgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgZ2V0U3VwcG9ydGVkTGFuZ3VhZ2VzKCk6IGxhbmdDb2RlW10ge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlXG5cdFx0Ly8gcHJldHRpZXItaWdub3JlXG5cdFx0cmV0dXJuIFtcblx0XHRcdCdlbicsICdhcicsICdhZicsICdiZycsICdjeScsICdodScsICd2aScsICdlbCcsICdkYScsICdoZScsXG5cdFx0XHQnaWQnLCAnaXMnLCAnZXMnLCAnaXQnLCAnY2EnLCAna28nLCAnaHQnLCAnbHYnLCAnbHQnLCAnbWcnLFxuXHRcdFx0J21zJywgJ210JywgJ2RlJywgJ25sJywgJ25iJywgJ2ZhJywgJ3BsJywgJ3B0JywgJ3JvJywgJ3J1Jyxcblx0XHRcdCdzbScsICdzaycsICdzbCcsICdzdycsICd0eScsICd0aCcsICd0YScsICd0ZScsICd0bycsICd0cicsXG5cdFx0XHQndWsnLCAndXInLCAnZmonLCAnZmknLCAnZnInLCAnaGknLCAnaHInLCAnY3MnLCAnc3YnLCAnZXQnLFxuXHRcdFx0J2phJyxcblx0XHRdO1xuXHRcdC8vIGVzbGludC1lbmFibGVcblx0fVxuXG5cdHB1YmxpYyBnZXRMZW5ndGhMaW1pdCgpIHtcblx0XHRyZXR1cm4gMzAwMDtcblx0fVxuXG5cdHB1YmxpYyBnZXRSZXF1ZXN0c1RpbWVvdXQoKSB7XG5cdFx0cmV0dXJuIDUwMDtcblx0fVxuXG5cdHB1YmxpYyBjaGVja0xpbWl0RXhjZWVkaW5nKHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcblx0XHRcdGNvbnN0IGVuY29kZWRUZXh0ID0gdGhpcy5tdHAuZW5jb2RlKFxuXHRcdFx0XHR0ZXh0Lm1hcCgodGV4dCwgaWQpID0+ICh7IHRleHQsIGlkOiAnJyArIGlkIH0pKSxcblx0XHRcdCk7XG5cdFx0XHRjb25zdCBleHRyYSA9IGVuY29kZWRUZXh0Lmxlbmd0aCAtIHRoaXMuZ2V0TGVuZ3RoTGltaXQoKTtcblx0XHRcdHJldHVybiBleHRyYSA+IDAgPyBleHRyYSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGV4dHJhID0gdGV4dC5sZW5ndGggLSB0aGlzLmdldExlbmd0aExpbWl0KCk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPiAwID8gZXh0cmEgOiAwO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZW5jb2RlT2JqZWN0KG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPikge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyhvYmopXG5cdFx0XHQubWFwKChrZXkpID0+IHtcblx0XHRcdFx0cmV0dXJuIGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSk7XG5cdFx0XHR9KVxuXHRcdFx0LmpvaW4oJyYnKTtcblx0fVxuXG5cdC8vIFRoaXMgZm4gd2FzIGNvcHkgZnJvbSB0b29sS2l0IGZvciBpbmRlcGVuZGVudGN5XG5cdHByaXZhdGUgZmluZEluT2JqKG9iajogYW55LCBwYXRoOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+LCBub3RGb3VuZCA9IHVuZGVmaW5lZCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5yZWR1Y2UoKHgsIHkpID0+IHtcblx0XHRcdFx0aWYgKHkgaW4geCkge1xuXHRcdFx0XHRcdHJldHVybiB4W3ldO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdOb3QgZm91bmQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb2JqKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gbm90Rm91bmQ7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGFzeW5jIHRyYW5zbGF0ZSh0ZXh0OiBzdHJpbmcsIGZyb206IGxhbmdDb2RlV2l0aEF1dG8sIHRvOiBsYW5nQ29kZSkge1xuXHRcdGNvbnN0IGZpeGVkRnJvbSA9IGZyb20gPT09ICdhdXRvJyA/ICdhdXRvLWRldGVjdCcgOiBmcm9tO1xuXG5cdFx0Y29uc3QgeyBJSUcsIElJRCwga2V5LCB0b2tlbiB9ID0gYXdhaXQgZ2V0Q29uZmlnKCk7XG5cblx0XHRyZXR1cm4gZmV0Y2goXG5cdFx0XHR0aGlzLndyYXBVcmxUb0NvcnNQcm94eShcblx0XHRcdFx0YGh0dHBzOi8vd3d3LmJpbmcuY29tL3R0cmFuc2xhdGV2Mz9pc1ZlcnRpY2FsPTEmPSZJRz0ke0lJR30mPSZJSUQ9JHtJSUR9YCxcblx0XHRcdCksXG5cdFx0XHR7XG5cdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0J0NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuXHRcdFx0XHRcdC4uLnRoaXMub3B0aW9ucy5oZWFkZXJzLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRib2R5OlxuXHRcdFx0XHRcdCcmJyArXG5cdFx0XHRcdFx0dGhpcy5lbmNvZGVPYmplY3Qoe1xuXHRcdFx0XHRcdFx0ZnJvbUxhbmc6IGZpeGVkRnJvbSxcblx0XHRcdFx0XHRcdHRvLFxuXHRcdFx0XHRcdFx0dGV4dCxcblx0XHRcdFx0XHRcdHRva2VuLFxuXHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0fSxcblx0XHQpXG5cdFx0XHQudGhlbihmZXRjaFJlc3BvbnNlVG9Kc29uKVxuXHRcdFx0LnRoZW4oKHJzcCkgPT4ge1xuXHRcdFx0XHRjb25zdCB0ZXh0ID0gdGhpcy5maW5kSW5PYmoocnNwLCBbMCwgJ3RyYW5zbGF0aW9ucycsIDAsICd0ZXh0J10pO1xuXHRcdFx0XHRpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCdTdGF0dXNDb2RlJyBpbiByc3ApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlcnJvci4gQ29kZSAke3JzcFsnU3RhdHVzQ29kZSddfWApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXJyb3JgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSBtdHAgPSBuZXcgTXVsdGlwbGV4b3IoeyB0b2tlblN0YXJ0OiAn8J+YgCcsIHRva2VuRW5kOiAn8J+YgycgfSk7XG5cdHB1YmxpYyB0cmFuc2xhdGVCYXRjaCh0ZXh0OiBzdHJpbmdbXSwgbGFuZ0Zyb206IGxhbmdDb2RlV2l0aEF1dG8sIGxhbmdUbzogbGFuZ0NvZGUpIHtcblx0XHRjb25zdCBlbmNvZGVkVGV4dCA9IHRoaXMubXRwLmVuY29kZShcblx0XHRcdHRleHQubWFwKCh0ZXh0LCBpZCkgPT4gKHsgdGV4dCwgaWQ6ICcnICsgaWQgfSkpLFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGUoZW5jb2RlZFRleHQsIGxhbmdGcm9tLCBsYW5nVG8pLnRoZW4oKHJhd1RyYW5zbGF0ZSkgPT4ge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gQXJyYXk8c3RyaW5nIHwgbnVsbD4odGV4dC5sZW5ndGgpO1xuXG5cdFx0XHRjb25zdCBkZWNvZGVkTWFwID0gdGhpcy5tdHAuZGVjb2RlKHJhd1RyYW5zbGF0ZSk7XG5cdFx0XHRkZWNvZGVkTWFwLmZvckVhY2goKHsgaWQsIHRleHQgfSkgPT4ge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9ICtpZDtcblx0XHRcdFx0cmVzdWx0W2luZGV4XSA9IHRleHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9KTtcblx0fVxufVxuIl0sImZpbGUiOiJ0cmFuc2xhdG9ycy91bnN0YWJsZS9CaW5nVHJhbnNsYXRvclB1YmxpYy9pbmRleC5qcyJ9
