var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var mp3Parser = require('mp3-parser');
import { langCodes } from '../util/languages';
import { GoogleTTS } from './GoogleTTS';
import { LingvaTTS } from './LingvaTTS';
[GoogleTTS, LingvaTTS].map(function (translatorClass) {
    describe("methods of TTS class \"".concat(translatorClass.name, "\""), function () {
        test("getAudioBuffer returns audio buffer", function () { return __awaiter(void 0, void 0, void 0, function () {
            var tts, audioBuffer, audioBufferView, parsedAudioFrame;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tts = new translatorClass();
                        return [4 /*yield*/, tts.getAudioBuffer('Hello world. This is a demo text from TTS module', 'en')];
                    case 1:
                        audioBuffer = _a.sent();
                        expect(audioBuffer.buffer).toBeInstanceOf(ArrayBuffer);
                        expect(typeof audioBuffer.type).toBe('string');
                        audioBufferView = new DataView(audioBuffer.buffer);
                        parsedAudioFrame = mp3Parser.readFrameHeader(audioBufferView);
                        expect(parsedAudioFrame).toHaveProperty('mpegAudioVersion');
                        expect(parsedAudioFrame).toHaveProperty('channelMode');
                        expect(parsedAudioFrame).toHaveProperty('samplingRate');
                        expect(parsedAudioFrame).toHaveProperty('bitrate');
                        return [2 /*return*/];
                }
            });
        }); });
        test("getSupportedLanguages returns array of supported languages", function () { return __awaiter(void 0, void 0, void 0, function () {
            var supportedLanguages;
            return __generator(this, function (_a) {
                supportedLanguages = translatorClass.getSupportedLanguages();
                // Languages array are not empty
                expect(Array.isArray(supportedLanguages)).toBeTruthy();
                expect(supportedLanguages.length).not.toEqual(0);
                expect(supportedLanguages.length > 0).toBeTruthy();
                // All language coded are correct
                supportedLanguages.forEach(function (lang) {
                    expect(langCodes.includes(lang));
                });
                return [2 /*return*/];
            });
        }); });
    });
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR0cy90dHMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFeEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUV2QyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQVcsQ0FBQyxHQUFHLENBQUMsVUFBQyxlQUFlO0lBQ3JELFFBQVEsQ0FBQyxpQ0FBeUIsZUFBZSxDQUFDLElBQUksT0FBRyxFQUFFO1FBQzFELElBQUksQ0FBQyxxQ0FBcUMsRUFBRTs7Ozs7d0JBQ3JDLEdBQUcsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO3dCQUNkLHFCQUFNLEdBQUcsQ0FBQyxjQUFjLENBQzNDLGtEQUFrRCxFQUNsRCxJQUFJLENBQ0osRUFBQTs7d0JBSEssV0FBVyxHQUFHLFNBR25CO3dCQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO3dCQUN2RCxNQUFNLENBQUMsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUd6QyxlQUFlLEdBQUcsSUFBSSxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUNuRCxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDO3dCQUNwRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQzt3QkFDNUQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO3dCQUN2RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7d0JBQ3hELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQzs7OzthQUNuRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsNERBQTRELEVBQUU7OztnQkFDNUQsa0JBQWtCLEdBQUcsZUFBZSxDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBRW5FLGdDQUFnQztnQkFDaEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUN2RCxNQUFNLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakQsTUFBTSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFFbkQsaUNBQWlDO2dCQUNqQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJO29CQUMvQixNQUFNLENBQUUsU0FBK0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDekQsQ0FBQyxDQUFDLENBQUM7OzthQUNILENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUMiLCJmaWxlIjoidHRzL3R0cy50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbXAzUGFyc2VyID0gcmVxdWlyZSgnbXAzLXBhcnNlcicpO1xuXG5pbXBvcnQgeyBsYW5nQ29kZXMgfSBmcm9tICcuLi91dGlsL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBHb29nbGVUVFMgfSBmcm9tICcuL0dvb2dsZVRUUyc7XG5pbXBvcnQgeyBMaW5ndmFUVFMgfSBmcm9tICcuL0xpbmd2YVRUUyc7XG5cbihbR29vZ2xlVFRTLCBMaW5ndmFUVFNdIGFzIGNvbnN0KS5tYXAoKHRyYW5zbGF0b3JDbGFzcykgPT4ge1xuXHRkZXNjcmliZShgbWV0aG9kcyBvZiBUVFMgY2xhc3MgXCIke3RyYW5zbGF0b3JDbGFzcy5uYW1lfVwiYCwgKCkgPT4ge1xuXHRcdHRlc3QoYGdldEF1ZGlvQnVmZmVyIHJldHVybnMgYXVkaW8gYnVmZmVyYCwgYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgdHRzID0gbmV3IHRyYW5zbGF0b3JDbGFzcygpO1xuXHRcdFx0Y29uc3QgYXVkaW9CdWZmZXIgPSBhd2FpdCB0dHMuZ2V0QXVkaW9CdWZmZXIoXG5cdFx0XHRcdCdIZWxsbyB3b3JsZC4gVGhpcyBpcyBhIGRlbW8gdGV4dCBmcm9tIFRUUyBtb2R1bGUnLFxuXHRcdFx0XHQnZW4nLFxuXHRcdFx0KTtcblxuXHRcdFx0ZXhwZWN0KGF1ZGlvQnVmZmVyLmJ1ZmZlcikudG9CZUluc3RhbmNlT2YoQXJyYXlCdWZmZXIpO1xuXHRcdFx0ZXhwZWN0KHR5cGVvZiBhdWRpb0J1ZmZlci50eXBlKS50b0JlKCdzdHJpbmcnKTtcblxuXHRcdFx0Ly8gUGFyc2UgYXMgYXVkaW8gZmlsZVxuXHRcdFx0Y29uc3QgYXVkaW9CdWZmZXJWaWV3ID0gbmV3IERhdGFWaWV3KGF1ZGlvQnVmZmVyLmJ1ZmZlcik7XG5cdFx0XHRjb25zdCBwYXJzZWRBdWRpb0ZyYW1lID0gbXAzUGFyc2VyLnJlYWRGcmFtZUhlYWRlcihhdWRpb0J1ZmZlclZpZXcpO1xuXHRcdFx0ZXhwZWN0KHBhcnNlZEF1ZGlvRnJhbWUpLnRvSGF2ZVByb3BlcnR5KCdtcGVnQXVkaW9WZXJzaW9uJyk7XG5cdFx0XHRleHBlY3QocGFyc2VkQXVkaW9GcmFtZSkudG9IYXZlUHJvcGVydHkoJ2NoYW5uZWxNb2RlJyk7XG5cdFx0XHRleHBlY3QocGFyc2VkQXVkaW9GcmFtZSkudG9IYXZlUHJvcGVydHkoJ3NhbXBsaW5nUmF0ZScpO1xuXHRcdFx0ZXhwZWN0KHBhcnNlZEF1ZGlvRnJhbWUpLnRvSGF2ZVByb3BlcnR5KCdiaXRyYXRlJyk7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KGBnZXRTdXBwb3J0ZWRMYW5ndWFnZXMgcmV0dXJucyBhcnJheSBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2VzYCwgYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc3VwcG9ydGVkTGFuZ3VhZ2VzID0gdHJhbnNsYXRvckNsYXNzLmdldFN1cHBvcnRlZExhbmd1YWdlcygpO1xuXG5cdFx0XHQvLyBMYW5ndWFnZXMgYXJyYXkgYXJlIG5vdCBlbXB0eVxuXHRcdFx0ZXhwZWN0KEFycmF5LmlzQXJyYXkoc3VwcG9ydGVkTGFuZ3VhZ2VzKSkudG9CZVRydXRoeSgpO1xuXHRcdFx0ZXhwZWN0KHN1cHBvcnRlZExhbmd1YWdlcy5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xuXHRcdFx0ZXhwZWN0KHN1cHBvcnRlZExhbmd1YWdlcy5sZW5ndGggPiAwKS50b0JlVHJ1dGh5KCk7XG5cblx0XHRcdC8vIEFsbCBsYW5ndWFnZSBjb2RlZCBhcmUgY29ycmVjdFxuXHRcdFx0c3VwcG9ydGVkTGFuZ3VhZ2VzLmZvckVhY2goKGxhbmcpID0+IHtcblx0XHRcdFx0ZXhwZWN0KChsYW5nQ29kZXMgYXMgcmVhZG9ubHkgc3RyaW5nW10pLmluY2x1ZGVzKGxhbmcpKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuIl19
