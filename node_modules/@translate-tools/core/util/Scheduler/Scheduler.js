"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;

var _QueueSemafor = require("../../lib/QueueSemafor");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/**
 * Module for scheduling and optimization of translate a text streams
 *
 * - It can union many translate requests to one
 * - You can group any requests by context
 * - It's configurable. You can set retry limit and edge for direct translate
 */
var Scheduler =
/** @class */
function () {
  function Scheduler(translator, config) {
    var _this = this;

    this.config = {
      translateRetryAttemptLimit: 2,
      isAllowDirectTranslateBadChunks: true,
      directTranslateLength: null,
      translatePoolDelay: 300,
      chunkSizeForInstantTranslate: null,
      taskBatchHandleDelay: null
    };
    this.contextCounter = 0;
    this.taskContainersStorage = new Set();
    this.timersMap = new Map();
    /**
     * Tasks queue with items sorted by priority
     * It must be handled from end to start
     */

    this.translateQueue = [];
    /**
     * Return first item from queue and delete it from queue
     * Items is sorted by priority
     */

    this.getItemFromTranslateQueue = function () {
      var _a;

      return {
        done: _this.translateQueue.length === 0,
        value: (_a = _this.translateQueue.pop()) !== null && _a !== void 0 ? _a : null
      };
    };

    this.workerState = false;
    this.translator = translator;

    if (config !== undefined) {
      for (var key in config) {
        this.config[key] = config[key];
      }
    }

    this.semafor = new _QueueSemafor.QueueSemafor({
      timeout: translator.getRequestsTimeout()
    });
  }

  Scheduler.prototype.translate = function (text, from, to, options) {
    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, context, _c, priority, _d, directTranslateForThisRequest;

      return __generator(this, function (_e) {
        _a = options !== undefined ? options : {}, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.priority, priority = _c === void 0 ? 0 : _c, _d = _a.directTranslate, directTranslateForThisRequest = _d === void 0 ? false : _d;

        if (this.translator.checkLimitExceeding(text) <= 0) {
          // Direct translate
          if (directTranslateForThisRequest || this.config.directTranslateLength !== null && text.length >= this.config.directTranslateLength) {
            return [2
            /*return*/
            , this.directTranslate(text, from, to)];
          } else {
            return [2
            /*return*/
            , this.makeTask({
              text: text,
              from: from,
              to: to,
              context: context,
              priority: priority
            })];
          }
        } else {
          // Split text by words and translate
          return [2
          /*return*/
          , this.splitAndTranslate(text, from, to, context, priority)];
        }

        return [2
        /*return*/
        ];
      });
    });
  };

  Scheduler.prototype.directTranslate = function (text, from, to) {
    return __awaiter(this, void 0, void 0, function () {
      var free;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.semafor.take()];

          case 1:
            free = _a.sent();
            return [2
            /*return*/
            , this.translator.translate(text, from, to).finally(free)];
        }
      });
    });
  };

  Scheduler.prototype.splitAndTranslate = function (text, from, to, context, priority) {
    var e_1, _a;

    var _this = this;

    var splittedText = [];
    var charsetIndexes = [];
    var wordsBuffer = '';

    try {
      for (var _b = __values(text.matchAll(/([^\s]+)(\s*)/g)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var textMatch = _c.value;
        var newPart = textMatch[0];
        var newBuffer = wordsBuffer + newPart; // Add word to buffer if can

        if (this.translator.checkLimitExceeding(newBuffer) <= 0) {
          wordsBuffer = newBuffer;
          continue;
        } // Write and clear buffer if not empthy


        if (wordsBuffer.length > 0) {
          splittedText.push(wordsBuffer);
          wordsBuffer = '';
        } // Handle new part


        if (this.translator.checkLimitExceeding(newPart) <= 0) {
          // Add to buffer
          wordsBuffer += newPart;
          continue;
        } else {
          // Slice by chars
          var charsBuffer = newPart;

          while (charsBuffer.length > 0) {
            var extraChars = this.translator.checkLimitExceeding(charsBuffer);

            if (extraChars > 0) {
              var offset = charsBuffer.length - extraChars; // Write slice and remainder

              splittedText.push(charsBuffer.slice(0, offset));
              charsBuffer = charsBuffer.slice(offset);
              charsetIndexes.push(splittedText.length - 1);
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    var ctxPrefix = context.length > 0 ? context + ';' : '';
    return Promise.all(splittedText.map(function (text, index) {
      return charsetIndexes.indexOf(index) !== -1 ? text : _this.makeTask({
        text: text,
        from: from,
        to: to,
        context: ctxPrefix + "text#".concat(_this.contextCounter++),
        priority: priority
      });
    })).then(function (translatedParts) {
      return translatedParts.join('');
    });
  };

  Scheduler.prototype.makeTask = function (_a) {
    var _this = this;

    var text = _a.text,
        from = _a.from,
        to = _a.to,
        priority = _a.priority,
        _b = _a.context,
        context = _b === void 0 ? '' : _b;
    return new Promise(function (resolve, reject) {
      _this.addToTaskContainer({
        text: text,
        from: from,
        to: to,
        context: context,
        priority: priority,
        resolve: resolve,
        reject: reject
      });
    });
  };

  Scheduler.prototype.addToTaskContainer = function (params) {
    var e_2, _a;

    var text = params.text,
        from = params.from,
        to = params.to,
        _b = params.attempt,
        attempt = _b === void 0 ? 0 : _b,
        _c = params.context,
        context = _c === void 0 ? '' : _c,
        priority = params.priority,
        resolve = params.resolve,
        reject = params.reject; // create task

    var task = {
      text: text,
      from: from,
      to: to,
      attempt: attempt,
      resolve: resolve,
      reject: reject
    };
    var container = null;

    var _loop_1 = function (taskContainer) {
      // Skip containers with not equal parameters
      if (['from', 'to', 'context', 'priority'].some(function (key) {
        return params[key] !== taskContainer[key];
      })) return "continue"; // Lightweight check to overflow
      // NOTE: Do strict check here if you need comply a limit contract

      if (this_1.translator.getLengthLimit() >= taskContainer.length + task.text.length) {
        taskContainer.tasks.push(task);
        taskContainer.length += task.text.length;
        container = taskContainer;
      }
    };

    var this_1 = this;

    try {
      // try add to exists container
      for (var _d = __values(this.taskContainersStorage), _e = _d.next(); !_e.done; _e = _d.next()) {
        var taskContainer = _e.value;

        _loop_1(taskContainer);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
      } finally {
        if (e_2) throw e_2.error;
      }
    } // make container


    if (container === null) {
      var newTaskContainer = {
        context: context,
        priority: priority,
        from: from,
        to: to,
        tasks: [task],
        length: task.text.length
      };
      this.taskContainersStorage.add(newTaskContainer);
      container = newTaskContainer;
    }

    if (this.config.chunkSizeForInstantTranslate !== null && container.length >= this.config.chunkSizeForInstantTranslate) {
      this.addToTranslateQueue(container);
    } else {
      this.updateDelayForAddToTranslateQueue(container);
    }
  };

  Scheduler.prototype.updateDelayForAddToTranslateQueue = function (taskContainer) {
    var _this = this; // Flush timer


    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
    }

    this.timersMap.set(taskContainer, globalThis.setTimeout(function () {
      _this.addToTranslateQueue(taskContainer);
    }, this.config.translatePoolDelay));
  };

  Scheduler.prototype.addToTranslateQueue = function (taskContainer) {
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
      this.timersMap.delete(taskContainer);
    }

    this.taskContainersStorage.delete(taskContainer); // Resort queue by priority each time to keep consistency

    this.translateQueue = this.translateQueue.concat(taskContainer).sort(function (a, b) {
      return a.priority - b.priority;
    });

    if (!this.workerState) {
      this.runWorker();
    }
  };

  Scheduler.prototype.runWorker = function () {
    return __awaiter(this, void 0, void 0, function () {
      var firstIteration, _loop_2, this_2, state_1;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.workerState = true;
            firstIteration = true;

            _loop_2 = function () {
              var workerHandleDelay, iterate, taskContainer, free, textArray;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    workerHandleDelay = this_2.config.taskBatchHandleDelay;
                    if (!(workerHandleDelay && firstIteration)) return [3
                    /*break*/
                    , 2];
                    return [4
                    /*yield*/
                    , new Promise(function (res) {
                      return setTimeout(res, workerHandleDelay);
                    })];

                  case 1:
                    _b.sent();

                    _b.label = 2;

                  case 2:
                    firstIteration = false;
                    iterate = this_2.getItemFromTranslateQueue(); // Skip when queue empty

                    if (iterate.done || iterate.value === null) return [2
                    /*return*/
                    , "break"];
                    taskContainer = iterate.value;
                    return [4
                    /*yield*/
                    , this_2.semafor.take()];

                  case 3:
                    free = _b.sent();
                    textArray = taskContainer.tasks.map(function (i) {
                      return i.text;
                    });
                    return [4
                    /*yield*/
                    , this_2.translator.translateBatch(textArray, taskContainer.from, taskContainer.to).then(function (result) {
                      for (var index in taskContainer.tasks) {
                        var task = taskContainer.tasks[index];
                        var translatedText = result[index];

                        if (translatedText !== null) {
                          task.resolve(translatedText);
                        } else {
                          _this.taskErrorHandler(task, new Error("Translator module can't translate this"), taskContainer.context, taskContainer.priority);
                        }
                      }
                    }).catch(function (reason) {
                      var e_3, _a;

                      console.error(reason);

                      try {
                        for (var _b = (e_3 = void 0, __values(taskContainer.tasks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var task = _c.value;

                          _this.taskErrorHandler(task, reason, taskContainer.context, taskContainer.priority);
                        }
                      } catch (e_3_1) {
                        e_3 = {
                          error: e_3_1
                        };
                      } finally {
                        try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                          if (e_3) throw e_3.error;
                        }
                      }
                    }).finally(free)];

                  case 4:
                    _b.sent();

                    return [2
                    /*return*/
                    ];
                }
              });
            };

            this_2 = this;
            _a.label = 1;

          case 1:
            if (!true) return [3
            /*break*/
            , 3];
            return [5
            /*yield**/
            , _loop_2()];

          case 2:
            state_1 = _a.sent();
            if (state_1 === "break") return [3
            /*break*/
            , 3];
            return [3
            /*break*/
            , 1];

          case 3:
            this.workerState = false;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  Scheduler.prototype.taskErrorHandler = function (task, error, context, priority) {
    if (task.attempt >= this.config.translateRetryAttemptLimit) {
      if (this.config.isAllowDirectTranslateBadChunks) {
        var text = task.text,
            from = task.from,
            to = task.to,
            resolve = task.resolve,
            reject = task.reject;
        this.directTranslate(text, from, to).then(resolve, reject);
      } else {
        task.reject(error);
      }
    } else {
      this.addToTaskContainer(__assign(__assign({}, task), {
        attempt: task.attempt + 1,
        context: context,
        priority: priority
      }));
    }
  };

  return Scheduler;
}();

exports.Scheduler = Scheduler;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvU2NoZWR1bGVyL1NjaGVkdWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJHQTs7Ozs7O0FBTUc7QUFDSCxJQUFBLFNBQUE7QUFBQTtBQUFBLFlBQUE7QUFZQyxXQUFBLFNBQUEsQ0FBWSxVQUFaLEVBQW1ELE1BQW5ELEVBQWtFO0FBQWxFLFFBQUEsS0FBQSxHQUFBLElBQUE7O0FBVGlCLFNBQUEsTUFBQSxHQUEyQjtBQUMzQyxNQUFBLDBCQUEwQixFQUFFLENBRGU7QUFFM0MsTUFBQSwrQkFBK0IsRUFBRSxJQUZVO0FBRzNDLE1BQUEscUJBQXFCLEVBQUUsSUFIb0I7QUFJM0MsTUFBQSxrQkFBa0IsRUFBRSxHQUp1QjtBQUszQyxNQUFBLDRCQUE0QixFQUFFLElBTGE7QUFNM0MsTUFBQSxvQkFBb0IsRUFBRTtBQU5xQixLQUEzQjtBQXFCVCxTQUFBLGNBQUEsR0FBaUIsQ0FBakI7QUFtSFMsU0FBQSxxQkFBQSxHQUF3QixJQUFJLEdBQUosRUFBeEI7QUF1RUEsU0FBQSxTQUFBLEdBQVksSUFBSSxHQUFKLEVBQVo7QUFnQmpCOzs7QUFHRzs7QUFDSyxTQUFBLGNBQUEsR0FBa0MsRUFBbEM7QUFxQlI7OztBQUdHOztBQUNLLFNBQUEseUJBQUEsR0FBNEIsWUFBQTs7O0FBQ25DLGFBQU87QUFDTixRQUFBLElBQUksRUFBRSxLQUFJLENBQUMsY0FBTCxDQUFvQixNQUFwQixLQUErQixDQUQvQjtBQUVOLFFBQUEsS0FBSyxFQUFFLENBQUEsRUFBQSxHQUFBLEtBQUksQ0FBQyxjQUFMLENBQW9CLEdBQXBCLEVB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S0FBSyxNQUFMLENBQVksMEJBQWhDLEVBQTREO0FBQzNELFVBQUksS0FBSyxNQUFMLENBQVksK0JBQWhCLEVBQWlEO0FBQ3hDLFlBQUEsSUFBSSxHQUFnQyxJQUFJLENBQXBDLElBQUo7QUFBQSxZQUFNLElBQUksR0FBMEIsSUFBSSxDQUE5QixJQUFWO0FBQUEsWUFBWSxFQUFFLEdBQXNCLElBQUksQ0FBMUIsRUFBZDtBQUFBLFlBQWdCLE9BQU8sR0FBYSxJQUFJLENBQWpCLE9BQXZCO0FBQUEsWUFBeUIsTUFBTSxHQUFLLElBQUksQ0FBVCxNQUEvQjtBQUNSLGFBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixJQUEzQixFQUFpQyxFQUFqQyxFQUFxQyxJQUFyQyxDQUEwQyxPQUExQyxFQUFtRCxNQUFuRDtBQUNBLE9BSEQsTUFHTztBQUNOLFFBQUEsSUFBSSxDQUFDLE1BQUwsQ0FBWSxLQUFaO0FBQ0E7QUFDRCxLQVBELE1BT087QUFDTixXQUFLLGtCQUFMLENBQXVCLFFBQUEsQ0FBQSxRQUFBLENBQUEsRUFBQSxFQUNuQixJQURtQixDQUFBLEVBQ2Y7QUFDUCxRQUFBLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTCxHQUFlLENBRGpCO0FBRVAsUUFBQSxPQUFPLEVBQUEsT0FGQTtBQUdQLFFBQUEsUUFBUSxFQUFBO0FBSEQsT0FEZSxDQUF2QjtBQU1BO0FBQ0QsR0FoQk87O0FBaUJULFNBQUEsU0FBQTtBQUFDLENBcFZELEVBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJVHJhbnNsYXRlT3B0aW9ucywgSVNjaGVkdWxlciB9IGZyb20gJy4vSVNjaGVkdWxlcic7XG5pbXBvcnQge1xuXHRsYW5nQ29kZSxcblx0bGFuZ0NvZGVXaXRoQXV0byxcblx0VHJhbnNsYXRvckluc3RhbmNlTWVtYmVycyxcbn0gZnJvbSAnLi4vLi4vdHlwZXMvVHJhbnNsYXRvcic7XG5pbXBvcnQgeyBRdWV1ZVNlbWFmb3IgfSBmcm9tICcuLi8uLi9saWIvUXVldWVTZW1hZm9yJztcblxuaW50ZXJmYWNlIENvbmZpZyB7XG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgZm9yIHJldHJ5IHJlcXVlc3Rcblx0ICovXG5cdHRyYW5zbGF0ZVJldHJ5QXR0ZW1wdExpbWl0PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBJZiB0cnVlIC0gcmVqZWN0ZWQgcmVxdWVzdHMgd2lsbCB1c2UgZGlyZWN0IHRyYW5zbGF0ZVxuXHQgKi9cblx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rcz86IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIExlbmd0aCBvZiBzdHJpbmcgZm9yIGRpcmVjdCB0cmFuc2xhdGUuXG5cdCAqXG5cdCAqIG51bGwgZm9yIGRpc2FibGUgdGhlIGNvbmRpdGlvblxuXHQgKi9cblx0ZGlyZWN0VHJhbnNsYXRlTGVuZ3RoPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogRGVsYXkgZm9yIHRyYW5zbGF0ZSBhIGNodW5rLiBUaGUgYmlnZ2VyIHRoZSBtb3JlIHJlcXVlc3RzIHdpbGwgY29sbGVjdFxuXHQgKi9cblx0dHJhbnNsYXRlUG9vbERlbGF5PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBXaGVuIGNodW5rIGNvbGxlY3QgdGhpcyBzaXplLCBpdCdzIHdpbGwgYmUgaW5zdGFudCBhZGQgdG8gYSB0cmFuc2xhdGUgcXVldWVcblx0ICpcblx0ICogbnVsbCBmb3IgZGlzYWJsZSB0aGUgY29uZGl0aW9uXG5cdCAqL1xuXHRjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogUGF1c2UgYmV0d2VlbiBoYW5kbGUgdGFzayBiYXRjaGVzXG5cdCAqXG5cdCAqIEl0IG1heSBiZSB1c2VmdWwgdG8gYXdhaXQgYWNjdW11bGF0aW5nIGEgdGFzayBiYXRjaGVzIGluIHF1ZXVlIHRvIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciBhbmQgZG9uJ3QgdHJhbnNsYXRlIGZpcnN0IHRhc2sgYmF0Y2ggaW1tZWRpYXRlbHlcblx0ICpcblx0ICogV0FSTklORzogdGhpcyBvcHRpb24gbXVzdCBiZSB1c2VkIG9ubHkgZm9yIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciEgU2V0IHNtYWxsIHZhbHVlIGFsd2F5cyAoMTAtNTBtcylcblx0ICpcblx0ICogV2hlbiB0aGlzIG9wdGlvbiBpcyBkaXNhYmxlZCAoYnkgZGVmYXVsdCkgYW5kIHlvdSBjYWxsIHRyYW5zbGF0ZSBtZXRob2QgZm9yIHRleHRzIHdpdGggcHJpb3JpdHkgMSBhbmQgdGhlbiBpbW1lZGlhdGVseSBmb3IgdGV4dCB3aXRoIHByaW9yaXR5IDIsIGZpcnN0IHJlcXVlc3Qgd2lsbCBoYXZlIGxlc3MgZGVsYXkgZm9yIHRyYW5zbGF0ZSBhbmQgd2lsbCB0cmFuc2xhdGUgZmlyc3QsIGV2ZW4gd2l0aCBsb3dlciBwcmlvcml0eSwgYmVjYXVzZSB3b3JrZXIgd2lsbCB0cmFuc2xhdGUgZmlyc3QgdGFzayBpbW1lZGlhdGVseSBhZnRlciBkZWxheSBkZWZpbmVkIGJ5IG9wdGlvbiBgdHJhbnNsYXRlUG9vbERlbGF5YFxuXHQgKi9cblx0dGFza0JhdGNoSGFuZGxlRGVsYXk/OiBudWxsIHwgbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVGFza0NvbnN0cnVjdG9yIHtcblx0dGV4dDogc3RyaW5nO1xuXHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvO1xuXHR0bzogbGFuZ0NvZGU7XG5cblx0LyoqXG5cdCAqIFRvIGNvbWJpbmUgdGFza3MgYnkgdW5pcXVlIGtleVxuXHQgKi9cblx0Y29udGV4dD86IHN0cmluZztcblxuXHQvKipcblx0ICogVG8gY29tYmluZSBhbmQgc29ydCB0YXNrcyBieSBwcmlvcml0eVxuXHQgKi9cblx0cHJpb3JpdHk6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRhc2tDb25zdHJ1Y3RvckludGVybmFsIGV4dGVuZHMgVGFza0NvbnN0cnVjdG9yIHtcblx0LyoqXG5cdCAqIEN1cnJlbnQgcmV0cnkgYXR0ZW1wdFxuXHQgKi9cblx0YXR0ZW1wdD86IG51bWJlcjtcblxuXHRyZXNvbHZlOiAodmFsdWU6IHN0cmluZyB8IFByb21pc2VMaWtlPHN0cmluZz4pID0+IHZvaWQ7XG5cdHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFRhc2sge1xuXHR0ZXh0OiBzdHJpbmc7XG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblxuXHQvKipcblx0ICogQ3VycmVudCByZXRyeSBhdHRlbXB0XG5cdCAqL1xuXHRhdHRlbXB0OiBudW1iZXI7XG5cblx0cmVzb2x2ZTogKHZhbHVlOiBzdHJpbmcgfCBQcm9taXNlTGlrZTxzdHJpbmc+KSA9PiB2b2lkO1xuXHRyZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBUYXNrQ29udGFpbmVyIHtcblx0LyoqXG5cdCAqIEZvciBjb21iaW5lIHRhc2tzIGJ5IHVuaXF1ZSBrZXlcblx0ICovXG5cdGNvbnRleHQ6IHN0cmluZztcblxuXHRwcmlvcml0eTogbnVtYmVyO1xuXG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblx0dGFza3M6IFRhc2tbXTtcblxuXHQvKipcblx0ICogVG90YWwgbGVuZ3RoIG9mIHRleHQgZnJvbSBhbGwgdGFza3Ncblx0ICovXG5cdGxlbmd0aDogbnVtYmVyO1xufVxuXG50eXBlIEl0ZXJhdG9yU3RlcDxUPiA9IHtcblx0ZG9uZTogYm9vbGVhbjtcblx0dmFsdWU6IFQgfCBudWxsO1xufTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgYW5kIG9wdGltaXphdGlvbiBvZiB0cmFuc2xhdGUgYSB0ZXh0IHN0cmVhbXNcbiAqXG4gKiAtIEl0IGNhbiB1bmlvbiBtYW55IHRyYW5zbGF0ZSByZXF1ZXN0cyB0byBvbmVcbiAqIC0gWW91IGNhbiBncm91cCBhbnkgcmVxdWVzdHMgYnkgY29udGV4dFxuICogLSBJdCdzIGNvbmZpZ3VyYWJsZS4gWW91IGNhbiBzZXQgcmV0cnkgbGltaXQgYW5kIGVkZ2UgZm9yIGRpcmVjdCB0cmFuc2xhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBpbXBsZW1lbnRzIElTY2hlZHVsZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IHNlbWFmb3I7XG5cdHByaXZhdGUgcmVhZG9ubHkgdHJhbnNsYXRvcjtcblx0cHJpdmF0ZSByZWFkb25seSBjb25maWc6IFJlcXVpcmVkPENvbmZpZz4gPSB7XG5cdFx0dHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQ6IDIsXG5cdFx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rczogdHJ1ZSxcblx0XHRkaXJlY3RUcmFuc2xhdGVMZW5ndGg6IG51bGwsXG5cdFx0dHJhbnNsYXRlUG9vbERlbGF5OiAzMDAsXG5cdFx0Y2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZTogbnVsbCxcblx0XHR0YXNrQmF0Y2hIYW5kbGVEZWxheTogbnVsbCxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcih0cmFuc2xhdG9yOiBUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLCBjb25maWc/OiBDb25maWcpIHtcblx0XHR0aGlzLnRyYW5zbGF0b3IgPSB0cmFuc2xhdG9yO1xuXG5cdFx0aWYgKGNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcblx0XHRcdFx0KHRoaXMuY29uZmlnIGFzIGFueSlba2V5XSA9IChjb25maWcgYXMgYW55KVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2VtYWZvciA9IG5ldyBRdWV1ZVNlbWFmb3IoeyB0aW1lb3V0OiB0cmFuc2xhdG9yLmdldFJlcXVlc3RzVGltZW91dCgpIH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjb250ZXh0Q291bnRlciA9IDA7XG5cdHB1YmxpYyBhc3luYyB0cmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGZyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0dG86IGxhbmdDb2RlLFxuXHRcdG9wdGlvbnM/OiBJVHJhbnNsYXRlT3B0aW9ucyxcblx0KSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHkgPSAwLFxuXHRcdFx0ZGlyZWN0VHJhbnNsYXRlOiBkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCA9IGZhbHNlLFxuXHRcdH0gPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG5cblx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcodGV4dCkgPD0gMCkge1xuXHRcdFx0Ly8gRGlyZWN0IHRyYW5zbGF0ZVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCB8fFxuXHRcdFx0XHQodGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoICE9PSBudWxsICYmXG5cdFx0XHRcdFx0dGV4dC5sZW5ndGggPj0gdGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRpcmVjdFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0byk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYWtlVGFzayh7IHRleHQ6IHRleHQsIGZyb20sIHRvLCBjb250ZXh0LCBwcmlvcml0eSB9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3BsaXQgdGV4dCBieSB3b3JkcyBhbmQgdHJhbnNsYXRlXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGxpdEFuZFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bywgY29udGV4dCwgcHJpb3JpdHkpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZGlyZWN0VHJhbnNsYXRlKHRleHQ6IHN0cmluZywgZnJvbTogbGFuZ0NvZGVXaXRoQXV0bywgdG86IGxhbmdDb2RlKSB7XG5cdFx0Y29uc3QgZnJlZSA9IGF3YWl0IHRoaXMuc2VtYWZvci50YWtlKCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLmZpbmFsbHkoZnJlZSk7XG5cdH1cblxuXHRwcml2YXRlIHNwbGl0QW5kVHJhbnNsYXRlKFxuXHRcdHRleHQ6IHN0cmluZyxcblx0XHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvLFxuXHRcdHRvOiBsYW5nQ29kZSxcblx0XHRjb250ZXh0OiBzdHJpbmcsXG5cdFx0cHJpb3JpdHk6IG51bWJlcixcblx0KSB7XG5cdFx0Y29uc3Qgc3BsaXR0ZWRUZXh0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGNoYXJzZXRJbmRleGVzOiBudW1iZXJbXSA9IFtdO1xuXG5cdFx0bGV0IHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0Zm9yIChjb25zdCB0ZXh0TWF0Y2ggb2YgdGV4dC5tYXRjaEFsbCgvKFteXFxzXSspKFxccyopL2cpKSB7XG5cdFx0XHRjb25zdCBuZXdQYXJ0ID0gdGV4dE1hdGNoWzBdO1xuXHRcdFx0Y29uc3QgbmV3QnVmZmVyID0gd29yZHNCdWZmZXIgKyBuZXdQYXJ0O1xuXG5cdFx0XHQvLyBBZGQgd29yZCB0byBidWZmZXIgaWYgY2FuXG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcobmV3QnVmZmVyKSA8PSAwKSB7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JpdGUgYW5kIGNsZWFyIGJ1ZmZlciBpZiBub3QgZW1wdGh5XG5cdFx0XHRpZiAod29yZHNCdWZmZXIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRzcGxpdHRlZFRleHQucHVzaCh3b3Jkc0J1ZmZlcik7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBuZXcgcGFydFxuXHRcdFx0aWYgKHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKG5ld1BhcnQpIDw9IDApIHtcblx0XHRcdFx0Ly8gQWRkIHRvIGJ1ZmZlclxuXHRcdFx0XHR3b3Jkc0J1ZmZlciArPSBuZXdQYXJ0O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFNsaWNlIGJ5IGNoYXJzXG5cdFx0XHRcdGxldCBjaGFyc0J1ZmZlciA9IG5ld1BhcnQ7XG5cdFx0XHRcdHdoaWxlIChjaGFyc0J1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgZXh0cmFDaGFycyA9IHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKGNoYXJzQnVmZmVyKTtcblx0XHRcdFx0XHRpZiAoZXh0cmFDaGFycyA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGNoYXJzQnVmZmVyLmxlbmd0aCAtIGV4dHJhQ2hhcnM7XG5cblx0XHRcdFx0XHRcdC8vIFdyaXRlIHNsaWNlIGFuZCByZW1haW5kZXJcblx0XHRcdFx0XHRcdHNwbGl0dGVkVGV4dC5wdXNoKGNoYXJzQnVmZmVyLnNsaWNlKDAsIG9mZnNldCkpO1xuXHRcdFx0XHRcdFx0Y2hhcnNCdWZmZXIgPSBjaGFyc0J1ZmZlci5zbGljZShvZmZzZXQpO1xuXG5cdFx0XHRcdFx0XHRjaGFyc2V0SW5kZXhlcy5wdXNoKHNwbGl0dGVkVGV4dC5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBjdHhQcmVmaXggPSBjb250ZXh0Lmxlbmd0aCA+IDAgPyBjb250ZXh0ICsgJzsnIDogJyc7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0c3BsaXR0ZWRUZXh0Lm1hcCgodGV4dCwgaW5kZXgpID0+XG5cdFx0XHRcdGNoYXJzZXRJbmRleGVzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuXHRcdFx0XHRcdD8gdGV4dFxuXHRcdFx0XHRcdDogdGhpcy5tYWtlVGFzayh7XG5cdFx0XHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0XHRcdHRvLFxuXHRcdFx0XHRcdFx0Y29udGV4dDogY3R4UHJlZml4ICsgYHRleHQjJHt0aGlzLmNvbnRleHRDb3VudGVyKyt9YCxcblx0XHRcdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRcdCAgfSksXG5cdFx0XHQpLFxuXHRcdCkudGhlbigodHJhbnNsYXRlZFBhcnRzKSA9PiB0cmFuc2xhdGVkUGFydHMuam9pbignJykpO1xuXHR9XG5cblx0cHJpdmF0ZSBtYWtlVGFzayh7IHRleHQsIGZyb20sIHRvLCBwcmlvcml0eSwgY29udGV4dCA9ICcnIH06IFRhc2tDb25zdHJ1Y3Rvcikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuYWRkVG9UYXNrQ29udGFpbmVyKHtcblx0XHRcdFx0dGV4dCxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRyZXNvbHZlLFxuXHRcdFx0XHRyZWplY3QsXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVhZG9ubHkgdGFza0NvbnRhaW5lcnNTdG9yYWdlID0gbmV3IFNldDxUYXNrQ29udGFpbmVyPigpO1xuXHRwcml2YXRlIGFkZFRvVGFza0NvbnRhaW5lcihwYXJhbXM6IFRhc2tDb25zdHJ1Y3RvckludGVybmFsKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4dCxcblx0XHRcdGZyb20sXG5cdFx0XHR0byxcblx0XHRcdGF0dGVtcHQgPSAwLFxuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHksXG5cdFx0XHRyZXNvbHZlLFxuXHRcdFx0cmVqZWN0LFxuXHRcdH0gPSBwYXJhbXM7XG5cblx0XHQvLyBjcmVhdGUgdGFza1xuXHRcdGNvbnN0IHRhc2s6IFRhc2sgPSB7XG5cdFx0XHR0ZXh0LFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvLFxuXHRcdFx0YXR0ZW1wdCxcblx0XHRcdHJlc29sdmUsXG5cdFx0XHRyZWplY3QsXG5cdFx0fTtcblxuXHRcdGxldCBjb250YWluZXI6IFRhc2tDb250YWluZXIgfCBudWxsID0gbnVsbDtcblxuXHRcdC8vIHRyeSBhZGQgdG8gZXhpc3RzIGNvbnRhaW5lclxuXHRcdGZvciAoY29uc3QgdGFza0NvbnRhaW5lciBvZiB0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZSkge1xuXHRcdFx0Ly8gU2tpcCBjb250YWluZXJzIHdpdGggbm90IGVxdWFsIHBhcmFtZXRlcnNcblx0XHRcdGlmIChcblx0XHRcdFx0Wydmcm9tJywgJ3RvJywgJ2NvbnRleHQnLCAncHJpb3JpdHknXS5zb21lKFxuXHRcdFx0XHRcdChrZXkpID0+IChwYXJhbXMgYXMgYW55KVtrZXldICE9PSAodGFza0NvbnRhaW5lciBhcyBhbnkpW2tleV0sXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vIExpZ2h0d2VpZ2h0IGNoZWNrIHRvIG92ZXJmbG93XG5cdFx0XHQvLyBOT1RFOiBEbyBzdHJpY3QgY2hlY2sgaGVyZSBpZiB5b3UgbmVlZCBjb21wbHkgYSBsaW1pdCBjb250cmFjdFxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLnRyYW5zbGF0b3IuZ2V0TGVuZ3RoTGltaXQoKSA+PVxuXHRcdFx0XHR0YXNrQ29udGFpbmVyLmxlbmd0aCArIHRhc2sudGV4dC5sZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0XHR0YXNrQ29udGFpbmVyLnRhc2tzLnB1c2godGFzayk7XG5cdFx0XHRcdHRhc2tDb250YWluZXIubGVuZ3RoICs9IHRhc2sudGV4dC5sZW5ndGg7XG5cdFx0XHRcdGNvbnRhaW5lciA9IHRhc2tDb250YWluZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBjb250YWluZXJcblx0XHRpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBuZXdUYXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyID0ge1xuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdHRhc2tzOiBbdGFza10sXG5cdFx0XHRcdGxlbmd0aDogdGFzay50ZXh0Lmxlbmd0aCxcblx0XHRcdH07XG5cdFx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5hZGQobmV3VGFza0NvbnRhaW5lcik7XG5cdFx0XHRjb250YWluZXIgPSBuZXdUYXNrQ29udGFpbmVyO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdHRoaXMuY29uZmlnLmNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGUgIT09IG51bGwgJiZcblx0XHRcdGNvbnRhaW5lci5sZW5ndGggPj0gdGhpcy5jb25maWcuY2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSB0aW1lcnNNYXAgPSBuZXcgTWFwPFRhc2tDb250YWluZXIsIG51bWJlciB8IE5vZGVKUy5UaW1lb3V0PigpO1xuXHRwcml2YXRlIHVwZGF0ZURlbGF5Rm9yQWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyc01hcC5zZXQoXG5cdFx0XHR0YXNrQ29udGFpbmVyLFxuXHRcdFx0Z2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXIpO1xuXHRcdFx0fSwgdGhpcy5jb25maWcudHJhbnNsYXRlUG9vbERlbGF5KSxcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRhc2tzIHF1ZXVlIHdpdGggaXRlbXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqIEl0IG11c3QgYmUgaGFuZGxlZCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKi9cblx0cHJpdmF0ZSB0cmFuc2xhdGVRdWV1ZTogVGFza0NvbnRhaW5lcltdID0gW107XG5cdHByaXZhdGUgYWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHRcdHRoaXMudGltZXJzTWFwLmRlbGV0ZSh0YXNrQ29udGFpbmVyKTtcblx0XHR9XG5cblx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5kZWxldGUodGFza0NvbnRhaW5lcik7XG5cblx0XHQvLyBSZXNvcnQgcXVldWUgYnkgcHJpb3JpdHkgZWFjaCB0aW1lIHRvIGtlZXAgY29uc2lzdGVuY3lcblx0XHR0aGlzLnRyYW5zbGF0ZVF1ZXVlID0gdGhpcy50cmFuc2xhdGVRdWV1ZVxuXHRcdFx0LmNvbmNhdCh0YXNrQ29udGFpbmVyKVxuXHRcdFx0LnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcblxuXHRcdGlmICghdGhpcy53b3JrZXJTdGF0ZSkge1xuXHRcdFx0dGhpcy5ydW5Xb3JrZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGZpcnN0IGl0ZW0gZnJvbSBxdWV1ZSBhbmQgZGVsZXRlIGl0IGZyb20gcXVldWVcblx0ICogSXRlbXMgaXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqL1xuXHRwcml2YXRlIGdldEl0ZW1Gcm9tVHJhbnNsYXRlUXVldWUgPSAoKTogSXRlcmF0b3JTdGVwPFRhc2tDb250YWluZXI+ID0+IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZG9uZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5sZW5ndGggPT09IDAsXG5cdFx0XHR2YWx1ZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5wb3AoKSA/PyBudWxsLFxuXHRcdH07XG5cdH07XG5cblx0cHJpdmF0ZSB3b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHRwcml2YXRlIGFzeW5jIHJ1bldvcmtlcigpIHtcblx0XHR0aGlzLndvcmtlclN0YXRlID0gdHJ1ZTtcblxuXHRcdGxldCBmaXJzdEl0ZXJhdGlvbiA9IHRydWU7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdC8vIERlbGF5IGZpcnN0IGl0ZXJhdGlvbiB0byBhd2FpdCBmaWxsIHRoZSBxdWV1ZSwgdG8gY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyXG5cdFx0XHRjb25zdCB3b3JrZXJIYW5kbGVEZWxheSA9IHRoaXMuY29uZmlnLnRhc2tCYXRjaEhhbmRsZURlbGF5O1xuXHRcdFx0aWYgKHdvcmtlckhhbmRsZURlbGF5ICYmIGZpcnN0SXRlcmF0aW9uKSB7XG5cdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCB3b3JrZXJIYW5kbGVEZWxheSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdEl0ZXJhdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBpdGVyYXRlID0gdGhpcy5nZXRJdGVtRnJvbVRyYW5zbGF0ZVF1ZXVlKCk7XG5cblx0XHRcdC8vIFNraXAgd2hlbiBxdWV1ZSBlbXB0eVxuXHRcdFx0aWYgKGl0ZXJhdGUuZG9uZSB8fCBpdGVyYXRlLnZhbHVlID09PSBudWxsKSBicmVhaztcblxuXHRcdFx0Y29uc3QgdGFza0NvbnRhaW5lciA9IGl0ZXJhdGUudmFsdWU7XG5cblx0XHRcdGNvbnN0IGZyZWUgPSBhd2FpdCB0aGlzLnNlbWFmb3IudGFrZSgpO1xuXG5cdFx0XHRjb25zdCB0ZXh0QXJyYXkgPSB0YXNrQ29udGFpbmVyLnRhc2tzLm1hcCgoaSkgPT4gaS50ZXh0KTtcblx0XHRcdGF3YWl0IHRoaXMudHJhbnNsYXRvclxuXHRcdFx0XHQudHJhbnNsYXRlQmF0Y2godGV4dEFycmF5LCB0YXNrQ29udGFpbmVyLmZyb20sIHRhc2tDb250YWluZXIudG8pXG5cdFx0XHRcdC50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGluZGV4IGluIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRhc2sgPSB0YXNrQ29udGFpbmVyLnRhc2tzW2luZGV4XTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNsYXRlZFRleHQgPSByZXN1bHRbaW5kZXhdO1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zbGF0ZWRUZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHRhc2sucmVzb2x2ZSh0cmFuc2xhdGVkVGV4dCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRhc2tFcnJvckhhbmRsZXIoXG5cdFx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJUcmFuc2xhdG9yIG1vZHVsZSBjYW4ndCB0cmFuc2xhdGUgdGhpc1wiKSxcblx0XHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdFx0dGFza0NvbnRhaW5lci5wcmlvcml0eSxcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgocmVhc29uKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihyZWFzb24pO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdHRoaXMudGFza0Vycm9ySGFuZGxlcihcblx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0cmVhc29uLFxuXHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIucHJpb3JpdHksXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmZpbmFsbHkoZnJlZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy53b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHR9XG5cblx0cHJpdmF0ZSB0YXNrRXJyb3JIYW5kbGVyKHRhc2s6IFRhc2ssIGVycm9yOiBhbnksIGNvbnRleHQ6IHN0cmluZywgcHJpb3JpdHk6IG51bWJlcikge1xuXHRcdGlmICh0YXNrLmF0dGVtcHQgPj0gdGhpcy5jb25maWcudHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQpIHtcblx0XHRcdGlmICh0aGlzLmNvbmZpZy5pc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzKSB7XG5cdFx0XHRcdGNvbnN0IHsgdGV4dCwgZnJvbSwgdG8sIHJlc29sdmUsIHJlamVjdCB9ID0gdGFzaztcblx0XHRcdFx0dGhpcy5kaXJlY3RUcmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhc2sucmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hZGRUb1Rhc2tDb250YWluZXIoe1xuXHRcdFx0XHQuLi50YXNrLFxuXHRcdFx0XHRhdHRlbXB0OiB0YXNrLmF0dGVtcHQgKyAxLFxuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuIl0sImZpbGUiOiJ1dGlsL1NjaGVkdWxlci9TY2hlZHVsZXIuanMifQ==
